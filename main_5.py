# =========================
# БАЗОВЫЙ КЛАСС
# =========================

class Animal:
    """
    Базовый (родительский) класс.
    Задаёт ОБЩИЙ интерфейс для всех животных.
    """

    def __init__(self, name):
        # Атрибут экземпляра — имя животного
        self.name = name

    def speak(self):
        """
        Абстрактный метод (по соглашению).
        Показывает, что каждый потомок ОБЯЗАН
        реализовать собственный вариант speak().
        """
        raise NotImplementedError("Метод speak() должен быть переопределён")

    def move(self):
        """
        Базовая реализация метода.
        Может быть переопределена в дочерних классах.
        """
        return "Животное двигается"

    def info(self):
        """
        Метод с общей логикой,
        которую можно расширять через super().
        """
        return f"Я животное, меня зовут {self.name}"


# =========================
# ОДИНОЧНОЕ НАСЛЕДОВАНИЕ
# =========================

class Dog(Animal):
    """
    Dog наследуется от Animal.
    Переопределяет поведение.
    """

    def speak(self):
        # Собственная реализация метода speak()
        return "Гав!"

    def move(self):
        # Переопределение метода родителя
        return "Собака бежит"


class Cat(Animal):
    """
    Cat — ещё один наследник Animal.
    """

    def speak(self):
        return "Мяу"

    def move(self):
        return "Кошка крадётся"


# =========================
# ПЕРЕОПРЕДЕЛЕНИЕ + super()
# =========================

class Wolf(Animal):
    """
    Демонстрация:
    - переопределения
    - вызова метода родителя через super()
    """

    def speak(self):
        return "Аууу"

    def info(self):
        # Вызываем родительскую версию info()
        base_info = super().info()
        # Расширяем её, а не переписываем полностью
        return base_info + " и я волк"


# =========================
# МИКСИНЫ (поведение)
# =========================

class Flyable:
    """
    Миксин — класс, добавляющий поведение.
    Обычно НЕ используется самостоятельно.
    """

    def move(self):
        return "Летает"


class Swimmable:
    """
    Второй миксин.
    """

    def move(self):
        return "Плавает"


# =========================
# МНОЖЕСТВЕННОЕ НАСЛЕДОВАНИЕ
# =========================

class Duck(Animal, Flyable, Swimmable):
    """
    Множественное наследование:
    Duck наследует сразу от нескольких классов.
    Порядок важен (MRO).
    """

    def speak(self):
        return "Кря"


class SuperDuck(Animal, Flyable, Swimmable):
    """
    Полное переопределение поведения move()
    """

    def speak(self):
        return "Супер-кря"

    def move(self):
        # Переопределяем ВСЕ версии move()
        return "Летает и плавает"


# =========================
# DUCK TYPING (без наследования)
# =========================

class Robot:
    """
    Robot НЕ наследуется от Animal,
    но имеет методы speak(), move(), info().
    """

    def speak(self):
        return "Бип-буп"

    def move(self):
        return "Едет на колёсах"

    def info(self):
        return "Я робот"


# =========================
# ПОЛИМОРФИЗМ В ДЕЙСТВИИ
# =========================

def make_it_act(entity):
    """
    Функция демонстрирует ПОЛИМОРФИЗМ.

    Ей не важно, кто entity:
    Animal, его потомок или вообще Robot.
    Главное — наличие нужных методов.
    """
    print("-" * 30)
    print(entity.speak())  # вызов конкретной реализации
    print(entity.move())   # вызов конкретной реализации
    print(entity.info())   # вызов конкретной реализации
    print("-" * 30, "\n")


# =========================
# ТЕСТИРОВАНИЕ ВСЕГО
# =========================

if __name__ == "__main__":
    # Список ОБЪЕКТОВ разных классов
    animals = [
        Dog("Бобик"),
        Cat("Мурка"),
        Wolf("Серый"),
        Duck("Дональд"),
        SuperDuck("Герой"),
        Robot()
    ]

    # Один и тот же код работает по-разному
    for obj in animals:
        make_it_act(obj)

    # Демонстрация порядка разрешения методов (MRO)
    print("\nMRO для Duck:")
    for cls in Duck.__mro__:
        print(" ", cls.__name__)
